{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar memoize = _interopDefault(require('lodash/memoize'));\n\nvar isDate = _interopDefault(require('lodash/isDate'));\n\nvar range = _interopDefault(require('lodash/range'));\n\nvar max = _interopDefault(require('lodash/max'));\n\nvar assign = _interopDefault(require('lodash/assign'));\n\nvar d3TimeFormat = require('d3-time-format');\n\nvar d3Time = require('d3-time');\n\nvar PropTypes = _interopDefault(require('prop-types'));\n\nvar core = require('@nivo/core');\n\nvar legends = require('@nivo/legends');\n\nvar React = _interopDefault(require('react'));\n\nvar compose = _interopDefault(require('recompose/compose'));\n\nvar withPropsOnChange = _interopDefault(require('recompose/withPropsOnChange'));\n\nvar pure = _interopDefault(require('recompose/pure'));\n\nvar defaultProps = _interopDefault(require('recompose/defaultProps'));\n\nvar minBy = _interopDefault(require('lodash/minBy'));\n\nvar maxBy = _interopDefault(require('lodash/maxBy'));\n\nvar d3Scale = require('d3-scale');\n\nvar setDisplayName = _interopDefault(require('recompose/setDisplayName'));\n\nvar DIRECTION_HORIZONTAL = 'horizontal';\nvar DIRECTION_VERTICAL = 'vertical';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n/**\n * Compute day cell size according to current context.\n *\n * @param {number} width\n * @param {number} height\n * @param {number} direction\n * @param {array}  yearRange\n * @param {number} yearSpacing\n * @param {number} daySpacing\n * @param {number} maxWeeks\n * @returns {number}\n */\n\n\nvar computeCellSize = function computeCellSize(_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      direction = _ref.direction,\n      yearRange = _ref.yearRange,\n      yearSpacing = _ref.yearSpacing,\n      daySpacing = _ref.daySpacing,\n      maxWeeks = _ref.maxWeeks;\n  var hCellSize = void 0;\n  var vCellSize = void 0;\n\n  if (direction === DIRECTION_HORIZONTAL) {\n    hCellSize = (width - daySpacing * maxWeeks) / maxWeeks;\n    vCellSize = (height - (yearRange.length - 1) * yearSpacing - yearRange.length * (8 * daySpacing)) / (yearRange.length * 7);\n  } else {\n    hCellSize = (width - (yearRange.length - 1) * yearSpacing - yearRange.length * (8 * daySpacing)) / (yearRange.length * 7);\n    vCellSize = (height - daySpacing * maxWeeks) / maxWeeks;\n  }\n\n  return Math.min(hCellSize, vCellSize);\n};\n/**\n * Computes month path and bounding box.\n *\n * @param {Date}   date\n * @param {number} cellSize\n * @param {number} yearIndex\n * @param {number} yearSpacing\n * @param {number} daySpacing\n * @param {string} direction\n * @returns { { path: string, bbox: { x: number, y: number, width: number, height: number } } }\n */\n\n\nvar monthPathAndBBox = function monthPathAndBBox(_ref2) {\n  var date = _ref2.date,\n      cellSize = _ref2.cellSize,\n      yearIndex = _ref2.yearIndex,\n      yearSpacing = _ref2.yearSpacing,\n      daySpacing = _ref2.daySpacing,\n      direction = _ref2.direction;\n  var t1 = new Date(date.getFullYear(), date.getMonth() + 1, 0); // first day of next month\n\n  var d0 = date.getDay(); // first day of month\n\n  var w0 = d3Time.timeWeek.count(d3Time.timeYear(date), date); // first week of month\n\n  var d1 = t1.getDay(); // last day of month\n\n  var w1 = d3Time.timeWeek.count(d3Time.timeYear(t1), t1); // last week of month\n  // offset according to year index\n\n  var xO = 0;\n  var yO = 0;\n  var yearOffset = yearIndex * (7 * (cellSize + daySpacing) + yearSpacing);\n\n  if (direction === DIRECTION_HORIZONTAL) {\n    yO = yearOffset;\n  } else {\n    xO = yearOffset;\n  }\n\n  var path = void 0;\n  var bbox = {\n    x: xO,\n    y: yO,\n    width: 0,\n    height: 0\n  };\n\n  if (direction === DIRECTION_HORIZONTAL) {\n    path = ['M' + (xO + (w0 + 1) * (cellSize + daySpacing)) + ',' + (yO + d0 * (cellSize + daySpacing)), 'H' + (xO + w0 * (cellSize + daySpacing)) + 'V' + (yO + 7 * (cellSize + daySpacing)), 'H' + (xO + w1 * (cellSize + daySpacing)) + 'V' + (yO + (d1 + 1) * (cellSize + daySpacing)), 'H' + (xO + (w1 + 1) * (cellSize + daySpacing)) + 'V' + yO, 'H' + (xO + (w0 + 1) * (cellSize + daySpacing)) + 'Z'].join('');\n    bbox.x = xO + w0 * (cellSize + daySpacing);\n    bbox.width = (w1 + 1) * (cellSize + daySpacing) - bbox.x;\n    bbox.height = 7 * (cellSize + daySpacing);\n  } else {\n    path = ['M' + (xO + d0 * (cellSize + daySpacing)) + ',' + (yO + (w0 + 1) * (cellSize + daySpacing)), 'H' + xO + 'V' + (yO + (w1 + 1) * (cellSize + daySpacing)), 'H' + (xO + (d1 + 1) * (cellSize + daySpacing)) + 'V' + (yO + w1 * (cellSize + daySpacing)), 'H' + (xO + 7 * (cellSize + daySpacing)) + 'V' + (yO + w0 * (cellSize + daySpacing)), 'H' + (xO + d0 * (cellSize + daySpacing)) + 'Z'].join('');\n    bbox.y = yO + w0 * (cellSize + daySpacing);\n    bbox.width = 7 * (cellSize + daySpacing);\n    bbox.height = (w1 + 1) * (cellSize + daySpacing) - bbox.y;\n  }\n\n  return {\n    path: path,\n    bbox: bbox\n  };\n};\n/**\n * Creates a memoized version of monthPathAndBBox function.\n */\n\n\nvar memoMonthPathAndBBox = memoize(monthPathAndBBox, function (_ref3) {\n  var date = _ref3.date,\n      cellSize = _ref3.cellSize,\n      yearIndex = _ref3.yearIndex,\n      yearSpacing = _ref3.yearSpacing,\n      daySpacing = _ref3.daySpacing,\n      direction = _ref3.direction;\n  return date.toString() + '.' + cellSize + '.' + yearIndex + '.' + yearSpacing + '.' + daySpacing + '.' + direction;\n});\n/**\n * Returns a function to Compute day cell position for horizontal layout.\n *\n * @param {number} cellSize\n * @param {number} yearSpacing\n * @param {number} daySpacing\n * @returns { function(): { x: number, y: number } }\n */\n\nvar cellPositionHorizontal = function cellPositionHorizontal(cellSize, yearSpacing, daySpacing) {\n  return function (d, yearIndex) {\n    var weekOfYear = d3Time.timeWeek.count(d3Time.timeYear(d), d);\n    return {\n      x: weekOfYear * (cellSize + daySpacing) + daySpacing / 2,\n      y: d.getDay() * (cellSize + daySpacing) + daySpacing / 2 + yearIndex * (yearSpacing + 7 * (cellSize + daySpacing))\n    };\n  };\n};\n/**\n * Returns a function to Compute day cell position for vertical layout.\n *\n * @param {number} cellSize\n * @param {number} yearSpacing\n * @param {number} daySpacing\n * @returns { function(): { x: number, y: number } }\n */\n\n\nvar cellPositionVertical = function cellPositionVertical(cellSize, yearSpacing, daySpacing) {\n  return function (d, yearIndex) {\n    var weekOfYear = d3Time.timeWeek.count(d3Time.timeYear(d), d);\n    return {\n      x: d.getDay() * (cellSize + daySpacing) + daySpacing / 2 + yearIndex * (yearSpacing + 7 * (cellSize + daySpacing)),\n      y: weekOfYear * (cellSize + daySpacing) + daySpacing / 2\n    };\n  };\n}; // used for days range and data matching\n\n\nvar dayFormat = d3TimeFormat.timeFormat('%Y-%m-%d');\n/**\n * This layout is responsible for computing Calendar chart data/positions….\n * It's used for all Calendar related chart components.\n *\n * @param {number}      width\n * @param {number}      height\n * @param {string|Date} from\n * @param {string|Date} to\n * @param {array}       data\n * @param {string}      direction\n * @param {object}      colorScale\n * @param {string}      emptyColor\n * @param {number}      yearSpacing\n * @param {number}      daySpacing\n * @returns {object}\n */\n\nvar CalendarLayout = function CalendarLayout(_ref4) {\n  var width = _ref4.width,\n      height = _ref4.height,\n      from = _ref4.from,\n      to = _ref4.to,\n      data = _ref4.data,\n      direction = _ref4.direction,\n      colorScale = _ref4.colorScale,\n      emptyColor = _ref4.emptyColor,\n      yearSpacing = _ref4.yearSpacing,\n      daySpacing = _ref4.daySpacing; // time related data\n\n  var fromDate = isDate(from) ? from : new Date(from);\n  var toDate = isDate(to) ? to : new Date(to);\n  var yearRange = range(fromDate.getFullYear(), toDate.getFullYear() + 1);\n  var maxWeeks = max(yearRange.map(function (year) {\n    return d3Time.timeWeeks(new Date(year, 0, 1), new Date(year + 1, 0, 1)).length;\n  })) + 1; // ——————————————————————————————————————————————————————————————————————————————————————————————————————\n  // Computes years/months/days\n  // ——————————————————————————————————————————————————————————————————————————————————————————————————————\n  // compute cellSize\n\n  var cellSize = computeCellSize({\n    width: width,\n    height: height,\n    direction: direction,\n    yearRange: yearRange,\n    yearSpacing: yearSpacing,\n    daySpacing: daySpacing,\n    maxWeeks: maxWeeks\n  }); // determine day cells positioning function according to layout direction\n\n  var cellPosition = void 0;\n\n  if (direction === DIRECTION_HORIZONTAL) {\n    cellPosition = cellPositionHorizontal(cellSize, yearSpacing, daySpacing);\n  } else {\n    cellPosition = cellPositionVertical(cellSize, yearSpacing, daySpacing);\n  }\n\n  var years = [];\n  var months = [];\n  var days = [];\n  yearRange.forEach(function (year, i) {\n    var yearStart = new Date(year, 0, 1);\n    var yearEnd = new Date(year + 1, 0, 1);\n    days = days.concat(d3Time.timeDays(yearStart, yearEnd).map(function (dayDate) {\n      return assign({\n        date: dayDate,\n        day: dayFormat(dayDate),\n        size: cellSize\n      }, cellPosition(dayDate, i));\n    }));\n    var yearMonths = d3Time.timeMonths(yearStart, yearEnd).map(function (monthDate) {\n      return _extends({\n        date: monthDate,\n        year: monthDate.getFullYear(),\n        month: monthDate.getMonth()\n      }, memoMonthPathAndBBox({\n        date: monthDate,\n        direction: direction,\n        yearIndex: i,\n        yearSpacing: yearSpacing,\n        daySpacing: daySpacing,\n        cellSize: cellSize\n      }));\n    });\n    months = months.concat(yearMonths);\n    years.push({\n      year: year,\n      bbox: {\n        x: yearMonths[0].bbox.x,\n        y: yearMonths[0].bbox.y,\n        width: yearMonths[11].bbox.x - yearMonths[0].bbox.x + yearMonths[11].bbox.width,\n        height: yearMonths[11].bbox.y - yearMonths[0].bbox.y + yearMonths[11].bbox.height\n      }\n    });\n  }); // ——————————————————————————————————————————————————————————————————————————————————————————————————————\n  // Computes days/data intersection\n  // ——————————————————————————————————————————————————————————————————————————————————————————————————————\n  //const color = scalePropToD3Scale(colorScale)\n\n  days.forEach(function (day) {\n    day.color = emptyColor;\n    data.forEach(function (dataDay) {\n      if (dataDay.day === day.day) {\n        day.value = dataDay.value;\n        day.color = colorScale(dataDay.value);\n      }\n    });\n  });\n  return {\n    years: years,\n    months: months,\n    days: days,\n    cellSize: cellSize\n  };\n};\n\nvar monthLabelFormat = d3TimeFormat.timeFormat('%b');\n/**\n * Calendar components propTypes.\n *\n * @type {object}\n */\n\nvar CalendarPropTypes = {\n  from: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(Date)]).isRequired,\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(Date)]).isRequired,\n  data: PropTypes.arrayOf(PropTypes.shape({\n    day: PropTypes.string.isRequired,\n    value: PropTypes.number.isRequired\n  })).isRequired,\n  domain: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.arrayOf(PropTypes.number)]).isRequired,\n  colors: PropTypes.arrayOf(PropTypes.string).isRequired,\n  colorScale: PropTypes.func.isRequired,\n  direction: PropTypes.oneOf([DIRECTION_HORIZONTAL, DIRECTION_VERTICAL]),\n  emptyColor: PropTypes.string.isRequired,\n  // years\n  yearLegend: PropTypes.func.isRequired,\n  yearSpacing: PropTypes.number.isRequired,\n  yearLegendOffset: PropTypes.number.isRequired,\n  // months\n  monthLegend: PropTypes.func.isRequired,\n  monthBorderWidth: PropTypes.number.isRequired,\n  monthBorderColor: PropTypes.string.isRequired,\n  monthLegendOffset: PropTypes.number.isRequired,\n  // days\n  daySpacing: PropTypes.number.isRequired,\n  dayBorderWidth: PropTypes.number.isRequired,\n  dayBorderColor: PropTypes.string.isRequired,\n  // interactivity\n  isInteractive: PropTypes.bool,\n  onClick: PropTypes.func.isRequired,\n  tooltipFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  tooltip: PropTypes.func,\n  legends: PropTypes.arrayOf(PropTypes.shape(_extends({}, legends.LegendPropShape, {\n    itemCount: PropTypes.number.isRequired\n  }))).isRequired\n  /**\n   * Calendar components defaultProps.\n   *\n   * @type {object}\n   */\n\n};\nvar CalendarDefaultProps = {\n  domain: 'auto',\n  colors: ['#61cdbb', '#97e3d5', '#e8c1a0', '#f47560'],\n  direction: DIRECTION_HORIZONTAL,\n  emptyColor: '#fff',\n  // years\n  yearLegend: function yearLegend(year) {\n    return year;\n  },\n  yearSpacing: 30,\n  yearLegendOffset: 10,\n  // months\n  monthLegend: function monthLegend(year, month, date) {\n    return monthLabelFormat(date);\n  },\n  monthBorderWidth: 2,\n  monthBorderColor: '#000',\n  monthLegendOffset: 6,\n  // days\n  daySpacing: 0,\n  dayBorderWidth: 1,\n  dayBorderColor: '#000',\n  // interactivity\n  isInteractive: true,\n  onClick: core.noop,\n  legends: []\n};\n\nvar CalendarDay = function CalendarDay(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      size = _ref.size,\n      color = _ref.color,\n      borderWidth = _ref.borderWidth,\n      borderColor = _ref.borderColor,\n      onClick = _ref.onClick,\n      showTooltip = _ref.showTooltip,\n      hideTooltip = _ref.hideTooltip;\n  return React.createElement('rect', {\n    x: x,\n    y: y,\n    width: size,\n    height: size,\n    style: {\n      fill: color,\n      strokeWidth: borderWidth,\n      stroke: borderColor\n    },\n    onClick: onClick,\n    onMouseEnter: showTooltip,\n    onMouseMove: showTooltip,\n    onMouseLeave: hideTooltip\n  });\n};\n\nCalendarDay.propTypes = {\n  onClick: PropTypes.func.isRequired,\n  data: PropTypes.object.isRequired,\n  x: PropTypes.number.isRequired,\n  y: PropTypes.number.isRequired,\n  size: PropTypes.number.isRequired,\n  color: PropTypes.string.isRequired,\n  borderWidth: PropTypes.number.isRequired,\n  borderColor: PropTypes.string.isRequired,\n  tooltipFormat: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  tooltip: PropTypes.func,\n  showTooltip: PropTypes.func.isRequired,\n  hideTooltip: PropTypes.func.isRequired,\n  theme: PropTypes.shape({\n    tooltip: PropTypes.shape({}).isRequired\n  }).isRequired\n};\nvar enhance = compose(withPropsOnChange(['data', 'onClick'], function (_ref2) {\n  var data = _ref2.data,\n      _onClick = _ref2.onClick;\n  return {\n    onClick: function onClick(event) {\n      return _onClick(data, event);\n    }\n  };\n}), withPropsOnChange(['data', 'color', 'showTooltip', 'tooltipFormat', 'tooltip', 'theme'], function (_ref3) {\n  var data = _ref3.data,\n      color = _ref3.color,\n      _showTooltip = _ref3.showTooltip,\n      tooltipFormat = _ref3.tooltipFormat,\n      tooltip = _ref3.tooltip,\n      theme = _ref3.theme;\n  if (data.value === undefined) return {\n    showTooltip: core.noop\n  };\n  return {\n    showTooltip: function showTooltip(event) {\n      return _showTooltip(React.createElement(core.BasicTooltip, {\n        id: '' + data.day,\n        value: data.value,\n        enableChip: true,\n        color: color,\n        theme: theme,\n        format: tooltipFormat,\n        renderContent: typeof tooltip === 'function' ? tooltip.bind(null, _extends({\n          color: color\n        }, data)) : null\n      }), event);\n    }\n  };\n}), pure);\nvar CalendarDay$1 = enhance(CalendarDay);\n\nvar CalendarMonthPath = function CalendarMonthPath(_ref) {\n  var path = _ref.path,\n      borderWidth = _ref.borderWidth,\n      borderColor = _ref.borderColor;\n  return React.createElement('path', {\n    d: path,\n    style: {\n      fill: 'none',\n      strokeWidth: borderWidth,\n      stroke: borderColor\n    }\n  });\n};\n\nCalendarMonthPath.propTypes = {\n  path: PropTypes.string.isRequired,\n  borderWidth: PropTypes.number.isRequired,\n  borderColor: PropTypes.string.isRequired\n};\nvar CalendarMonthPath$1 = pure(CalendarMonthPath);\n\nvar enhance$1 = function enhance$1(Component) {\n  return compose(defaultProps(CalendarDefaultProps), core.withTheme(), core.withDimensions(), withPropsOnChange(['data', 'domain', 'colors'], function (_ref) {\n    var data = _ref.data,\n        domain = _ref.domain,\n        colors = _ref.colors;\n    var colorDomain = void 0;\n\n    if (domain === 'auto') {\n      if (data.length === 0) {\n        colorDomain = [0, 0];\n      } else {\n        colorDomain = [minBy(data, 'value').value, maxBy(data, 'value').value];\n      }\n    } else {\n      colorDomain = [].concat(domain);\n    }\n\n    var colorScale = d3Scale.scaleQuantize().domain(colorDomain).range(colors);\n    return {\n      colorScale: colorScale\n    };\n  }), pure)(Component);\n};\n\nvar Calendar = function Calendar(_ref) {\n  var data = _ref.data,\n      from = _ref.from,\n      to = _ref.to,\n      colorScale = _ref.colorScale,\n      margin = _ref.margin,\n      width = _ref.width,\n      height = _ref.height,\n      outerWidth = _ref.outerWidth,\n      outerHeight = _ref.outerHeight,\n      direction = _ref.direction,\n      yearLegend = _ref.yearLegend,\n      yearSpacing = _ref.yearSpacing,\n      yearLegendOffset = _ref.yearLegendOffset,\n      monthLegend = _ref.monthLegend,\n      monthBorderWidth = _ref.monthBorderWidth,\n      monthBorderColor = _ref.monthBorderColor,\n      monthLegendOffset = _ref.monthLegendOffset,\n      daySpacing = _ref.daySpacing,\n      dayBorderWidth = _ref.dayBorderWidth,\n      dayBorderColor = _ref.dayBorderColor,\n      emptyColor = _ref.emptyColor,\n      theme = _ref.theme,\n      isInteractive = _ref.isInteractive,\n      tooltipFormat = _ref.tooltipFormat,\n      tooltip = _ref.tooltip,\n      onClick = _ref.onClick,\n      legends$$1 = _ref.legends;\n\n  var _computeCalendar = CalendarLayout({\n    width: width,\n    height: height,\n    from: from,\n    to: to,\n    data: data,\n    direction: direction,\n    colorScale: colorScale,\n    emptyColor: emptyColor,\n    yearSpacing: yearSpacing,\n    daySpacing: daySpacing\n  }),\n      years = _computeCalendar.years,\n      months = _computeCalendar.months,\n      days = _computeCalendar.days;\n\n  return React.createElement(core.Container, {\n    isInteractive: isInteractive,\n    theme: theme\n  }, function (_ref2) {\n    var showTooltip = _ref2.showTooltip,\n        hideTooltip = _ref2.hideTooltip;\n    return React.createElement(core.SvgWrapper, {\n      width: outerWidth,\n      height: outerHeight,\n      margin: margin,\n      theme: theme\n    }, days.map(function (d) {\n      return React.createElement(CalendarDay$1, {\n        key: d.date.toString(),\n        data: d,\n        x: d.x,\n        y: d.y,\n        size: d.size,\n        color: d.color,\n        borderWidth: dayBorderWidth,\n        borderColor: dayBorderColor,\n        showTooltip: showTooltip,\n        hideTooltip: hideTooltip,\n        tooltipFormat: tooltipFormat,\n        tooltip: tooltip,\n        theme: theme,\n        onClick: onClick\n      });\n    }), months.map(function (m) {\n      return React.createElement(CalendarMonthPath$1, {\n        key: m.date.toString(),\n        path: m.path,\n        borderWidth: monthBorderWidth,\n        borderColor: monthBorderColor\n      });\n    }), months.map(function (month) {\n      var transform = void 0;\n\n      if (direction === DIRECTION_HORIZONTAL) {\n        transform = 'translate(' + (month.bbox.x + month.bbox.width / 2) + ',' + (month.bbox.y - monthLegendOffset) + ')';\n      } else {\n        transform = 'translate(' + (month.bbox.x - monthLegendOffset) + ',' + (month.bbox.y + month.bbox.height / 2) + ') rotate(-90)';\n      }\n\n      return React.createElement('text', {\n        key: month.date.toString() + '.legend',\n        className: 'nivo_calendar_month_legend',\n        transform: transform,\n        textAnchor: 'middle',\n        style: theme.labels.text\n      }, monthLegend(month.year, month.month, month.date));\n    }), years.map(function (year) {\n      var transform = void 0;\n\n      if (direction === DIRECTION_HORIZONTAL) {\n        transform = 'translate(' + (year.bbox.x - yearLegendOffset) + ',' + (year.bbox.y + year.bbox.height / 2) + ') rotate(-90)';\n      } else {\n        transform = 'translate(' + (year.bbox.x + year.bbox.width / 2) + ',' + (year.bbox.y - yearLegendOffset) + ')';\n      }\n\n      return React.createElement('text', {\n        key: year.year,\n        className: 'nivo_calendar_year_legend',\n        transform: transform,\n        textAnchor: 'middle',\n        style: theme.labels.text\n      }, yearLegend(year.year));\n    }), legends$$1.map(function (legend, i) {\n      var legendData = colorScale.ticks(legend.itemCount).map(function (value) {\n        return {\n          id: value,\n          label: value,\n          color: colorScale(value)\n        };\n      });\n      return React.createElement(legends.BoxLegendSvg, _extends({\n        key: i\n      }, legend, {\n        containerWidth: width,\n        containerHeight: height,\n        data: legendData,\n        theme: theme\n      }));\n    }));\n  });\n};\n\nCalendar.propTypes = CalendarPropTypes;\nvar Calendar$1 = setDisplayName('Calendar')(enhance$1(Calendar));\n\nvar ResponsiveCalendar = function ResponsiveCalendar(props) {\n  return React.createElement(core.ResponsiveWrapper, null, function (_ref) {\n    var width = _ref.width,\n        height = _ref.height;\n    return React.createElement(Calendar$1, _extends({\n      width: width,\n      height: height\n    }, props));\n  });\n};\n\nexports.Calendar = Calendar$1;\nexports.ResponsiveCalendar = ResponsiveCalendar;\nexports.CalendarPropTypes = CalendarPropTypes;\nexports.CalendarDefaultProps = CalendarDefaultProps;","map":null,"metadata":{},"sourceType":"script"}